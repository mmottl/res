{
  "name": "Res",
  "tagline": "OCaml library for resizable arrays and strings",
  "body": "RES - Automatically Resizing Contiguous Memory for OCaml\r\n========================================================\r\n\r\n---------------------------------------------------------------------------\r\n\r\nWhat is RES?\r\n------------\r\n\r\nThis OCaml-library consists of a set of modules which implement automatically\r\nresizing (= reallocating) data structures that consume a contiguous part\r\nof memory.  This allows appending and removing of elements to/from arrays\r\n(both boxed and unboxed), strings (buffers), bit strings and weak arrays\r\nwhile still maintaining fast constant-time access to elements.\r\n\r\nThere are also functors that allow the generation of similar modules which\r\nuse different reallocation strategies.\r\n\r\nFeatures\r\n--------\r\n\r\n  * Fast constant-time access to indexed elements (e.g. in arrays and\r\n    strings) is often a prerequisite for short execution times of programs.\r\n\r\n    Still, operations like adding and/or removing elements to/from the\r\n    end of such data structures are often needed.  Unfortunately, having\r\n    both properties at the same time sometimes requires reallocating this\r\n    contiguous part of memory.\r\n\r\n    This module does not eliminate this problem, but hides the process of\r\n    reallocation from the user, i.e. it happens automatically.\r\n\r\n    Thus, the user is liberated from this bug-attracting (e.g. index errors)\r\n    task.\r\n\r\n  * This library allows the user to parameterize allocation strategies at\r\n    runtime.  This is an important feature, because it is impossible for\r\n    any allocation algorithm to perform optimally without having knowledge\r\n    about the user program.\r\n\r\n    For example, the programmer might know that a consecutive series of\r\n    operations will alternately add and remove large batches of elements.\r\n    In such a case it would be wise to keep a high reserve of available slots\r\n    in the data structure, because otherwise it will resize very often during\r\n    this procedure which requires a significant amount of time.\r\n\r\n    By raising a corresponding threshold in appropriate places at runtime,\r\n    programmers can fine-tune the behavior of e.g. their buffers for optimal\r\n    performance and set this parameter back later to save memory.\r\n\r\n  * Because optimal reallocation strategies may be quite complex,\r\n    it was also a design goal to have users supply their own ones (if\r\n    required).\r\n\r\n    By using functors users can parameterize these data structures with\r\n    their own reallocation strategies, giving them even more control over\r\n    how and when reallocations are triggered.\r\n\r\n  * Users may want to add support for additional low-level implementations\r\n    that require reallocations.  In this case, too, it is fairly easy to\r\n    create new modules by using functors.\r\n\r\n  * The library implements a large interface of functions, all of which\r\n    are completely independent of the reallocation strategy and the low-level\r\n    implementation.\r\n\r\n    All the interfaces of the corresponding low-level implementations of\r\n    data structures (e.g. array, string) are fully supported and have been\r\n    extended with further functionality.  There is even a new buffer module\r\n    which can be used in every context of the standard one.\r\n\r\n  * OCaml makes a distinction between unboxed and boxed arrays.  If the type\r\n    of an array is `float`, the representation will be unboxed in cases in\r\n    which the array is not used in a polymorphic context (native code only).\r\n\r\n    To benefit from these much faster representations there are specialized\r\n    versions of automatically resizing arrays in the distribution.\r\n\r\nUsage\r\n-----\r\n\r\nThe API is fully documented and can be built as HTML using `make doc`.\r\nIt is also available [online](http://mmottl.github.io/res/api).\r\n\r\nThe preparameterized modules (default strategy) and the functors for mapping\r\nstrategy-implementations to this kind of modules are contained and documented\r\nin file `lib/res.mli`.\r\n\r\nFor examples of how to use the functors to implement new strategies and/or\r\nlow-level representations, take a look at the implementation in `lib/res.ml`.\r\n\r\nTheir function interface, however, is documented in files `lib/pres_intf.ml`\r\n(for parameterized \"low-level\" types like e.g. normal arrays) and in\r\n`lib/nopres_intf.ml` (for non-parameterized \"low-level\" types like e.g. float\r\narrays, strings (buffers), etc.).\r\n\r\n### Convenience\r\n\r\nIt should be noted that it is possible to use the standard notation for\r\naccessing elements (e.g. `ar.(42)`) with resizable arrays (and even with\r\n`Buffer`, `Bits`, etc...).  This requires a short explanation of how OCaml\r\ntreats such syntactic sugar:\r\n\r\nAll that OCaml does is that it replaces such syntax with an appropriate\r\n`Array.get` or `Array.set`.  This may be _any_ module that happens to be\r\nbound to this name in the current scope.  The same principle is true for the\r\n`String`-module and the `.[]`-operator.\r\n\r\nThus, the following works:\r\n\r\n```ocaml\r\nmodule Array = Res.Bits\r\nmodule String = Res.Buffer\r\n\r\nlet () =\r\n  let ar = Array.empty () in\r\n  Array.add_one ar true;\r\n  print_endline (string_of_bool ar.(0));\r\n  let str = String.empty () in\r\n  String.add_one str 'x';\r\n  print_char str.[0];\r\n  print_newline ()\r\n```\r\n\r\nDo not forget that it is even possible to bind modules locally.  Example:\r\n\r\n```ocaml\r\nlet () =\r\n  let module Array = Res.Array in\r\n  Printf.printf \"%d\\n\" (Array.init 10 (fun x -> x * x)).(7)\r\n```\r\n\r\nIf you want to change one of your files to make use of resizable arrays\r\ninstead of standard ones without much trouble, please read the following:\r\n\r\nYou may want to \"save\" the standard `Array`-module and its type for later\r\naccess:\r\n\r\n```ocaml\r\nmodule StdArray = Array\r\ntype 'a std_array = 'a array\r\n```\r\n\r\nMake the resizable implementation (includes the index operators!) available:\r\n\r\n```ocaml\r\nopen Res\r\n```\r\n\r\nOr more explicitly:\r\n\r\n```ocaml\r\nmodule Array = Res.Array\r\n```\r\n\r\nOr if you want to use a specific `Array`-implementation:\r\n\r\n```ocaml\r\nmodule Array = Res.Bits\r\n```\r\n\r\nThen set the type:\r\n\r\n```ocaml\r\ntype 'a array = 'a Array.t\r\n```\r\n\r\nIf you create standard arrays with the built-in syntax, change lines like:\r\n\r\n```ocaml\r\nlet ar = [| 1; 2; 3; 4 |] in\r\n```\r\n\r\nto:\r\n\r\n```ocaml\r\nlet ar = Array.of_array [| 1; 2; 3; 4 |] in\r\n```\r\n\r\nThis should allow all of your sources to compile out-of-the-box with the\r\nadditional functionality.  In places where you still need the standard\r\nimplementation you should have no problems to use the rebound module\r\nand type to do so.\r\n\r\nThis trick works similarly for the old and the new Buffer-module.  You might\r\nalso want to replace the `String`-module in this fashion.  The latter one,\r\nhowever, supports a number of functions like e.g. `escape`, which are not\r\navailable then.\r\n\r\n---------------------------------------------------------------------------\r\n\r\nContact Information and Contributing\r\n------------------------------------\r\n\r\nIn the case of bugs, feature requests, contributions and similar, you can\r\ncontact me here: <markus.mottl@gmail.com>\r\n\r\nUp-to-date information should be available at: <http://mmottl.github.io/res>\r\n\r\nEnjoy!\r\n\r\nMarkus Mottl on July 10, 2012\r\n",
  "google": "",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}